(IN PROGRESS, NOT READY FOR PRIME TIME)

# Match Query Parser
This query parser gives you very fine control over how an individual field is queried. This control comes in two phases:

## 1. Control query string parsing by specifying any analyzer

Use *any* analyzer to use to parse your query string -- even an analyzer unassociated with the field you're searching. Instead of the default whitespace delimited methods, you take very specific control over what terms are searched for. 

Let's take an example. You decide you want to change how a field `body` is searched. This field uses a boring solr field type like

```
    <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100" multiValued="true">
      <analyzer>
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
      </analyzer>
      <analyzer type="query">
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
      </analyzer>
    </fieldType>
```

But you decide that in addition to searching the boring way (tokenization and lowercasing) you also want to search using synonyms. So you create a dummy field type 

```
    <fieldType name="text_general_syn" class="solr.TextField" positionIncrementGap="100" multiValued="true">
      <analyzer type="query">
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" tokenizer="keyword" ignoreCase="true" expand="true"/>
      </analyzer>
    </fieldType>
```

With match query parser, you can search the same field both with either query-time analysis performed. Here we use match as a boost query on top of a base edismax query

`q=sea biscuit&defType=edismax&qf=body&bq={!match qf=body analyzer=text_general_syn v=$q}`

This query will search for sea biscuit in field body, but will also search for all terms generated by the query analyzer of `text_general_syn`. This includes `seabiscuit`, `[sea biscuit the lovely horse].` (one big term because the synonyms use the keyword tokenizer).

## 2. Control how terms resulting from query-time analysis result in Lucene queries

By default, match will turn the resulting tokens into term queries that are OR'd together. For example, above we searched for [seabiscuit] OR [sea biscuit the lovely horse].

But you can also tell match to decompose multi-word tokens into phrase queries instead of treating them as a single unit. You do this by setting the `ct` param (clause type) to "phrase." 

``q=sea biscuit&defType=edismax&qf=body&bq={!match qf=body analyzer=text_general_syn ct=phrase v=$q}`

This will output a query for 

`seabiscuit` OR `"sea biscuit the lovely horse"`

An optional `pslop` parameter is available to control the slop of this query.

(yes this is somewhat inspired by Elasticsearch's [match query](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html))
