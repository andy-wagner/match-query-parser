(IN PROGRESS, NOT READY FOR PRIME TIME)

# Match Query Parser
This query parser gives you very fine control over how an individual field is queried. This control comes in two phases:

## 1. Query-time analysis control

Use *any* analyzer to use to parse your query string -- even an analyzer unassociated with the field you're searching. Instead of the default whitespace delimited methods, you take very specific control over what terms are searched for. 

Let's take an example. You decide you want to change how a field `body` is searched. This field uses a boring solr field type like

```
    <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100" multiValued="true">
      <analyzer>
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
      </analyzer>
      <analyzer type="query">
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
      </analyzer>
    </fieldType>
```

But you decide that in addition to searching the boring way (tokenization and lowercasing) you also want to search using synonyms. So you create a dummy field type 

```
    <fieldType name="text_general_syn" class="solr.TextField" positionIncrementGap="100" multiValued="true">
      <analyzer type="query">
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
      </analyzer>
    </fieldType>
```

With match query parser, you can search the same field both with either query-time analysis performed. Here we use match as a boost query on top of a base edismax query

`q=sea biscuit&defType=edismax&qf=body&bq={!match qf=body analyzer=text_general_syn v=$q}`

This query will search for sea biscuit in field body, but will also search for all terms generated by the query analyzer of `text_general_syn`. This includes `seabiscuit`, `[sea] [biscuit] [the] [lovely] [horse].` 

## 2. Control what queries are performed.

By default, match will turn the resulting tokens into term queries that are OR'd together. For example, above we searched for [sea] OR [biscuit] OR [the] OR [lovely] OR [horse].

But you can also tell match to construct phrase queries using several strategies

- phrase_terms: If the terms are actually two word bigrams [sea biscuit], tokenize and make a phrase query "[sea] [biscuit]"
- auto_bigram: adjacent terms are made bigrams
- full_phrase: entire query is made a phrase
